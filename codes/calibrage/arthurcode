import cv2
import cv2.aruco as aruco
import numpy as np


def calculate_perspective_transform_matrix(Corner1, Corner2, Corner3, Corner4, size):
    # Define the destination points for perspective transformation
    dst_points = np.float32([[0, 0], [size[0], 0], [0, size[1]], [size[0], size[1]]])

    # Extract the corners of the detected ArUco markers
    src_points = np.float32([Corner1, Corner2, Corner3, Corner4])

    # Calculate perspective transformation matrix
    M = cv2.getPerspectiveTransform(src_points, dst_points)

    return M


def get_mean_hsv(image, center):
    """
    Get the mean HSV value in a 5 pixel radius circle around a specified center.
    Args:
        image: Input image in BGR format.
        center: Tuple containing the (x, y) coordinates of the circle center.
    Returns:
        Tuple containing the mean HSV value (Hue, Saturation, Value).
    """
    x, y = center
    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    circle_mask = np.zeros_like(hsv_image[:, :, 0], dtype=np.uint8)
    cv2.circle(circle_mask, center, 2, 255, -1)
    mean_hsv = cv2.mean(hsv_image, mask=circle_mask)[:3]
    return tuple(map(round, mean_hsv))


# Mettre à 0 pour camera, 1 pour photos
TEST = 1

final_size = (1200, 800)

# Taille réelle de l'ArUco en millimètres
taille_reelle_aruco_mm = 42.0  # Modifier cette valeur selon la taille réelle de votre ArUco

if TEST != 1:
    cap = cv2.VideoCapture(0)

aruco_dict = aruco.getPredefinedDictionary(aruco.DICT_ARUCO_ORIGINAL)

parameters = aruco.DetectorParameters()
detector = aruco.ArucoDetector(aruco_dict, parameters)

nomImages = ("Images\PhotoCam2_1.jpg", "Images\PhotoCarteRobot8.jpg", "Images\ConfigBlocsAvecArucoCote1.jpg", "Images\PhotoCarteTelephone5.jpg",
             "Images\ConfigBlocsAvecArucoCote3.jpg", "Images\ConfigBlocsAvecArucoDessusLoin1.jpg",
             "Images\ConfigBlocsAvecArucoDessusProche1.jpg")
nbImages = len(nomImages)

frame = cv2.imread(nomImages[0])

cpt = 1

# 170*100      der = 22   h = b = 40

while True:
    if TEST == 0:
        ret, frame = cap.read()
    elif TEST == 1:
        frame = cv2.imread(nomImages[cpt])
        frame = cv2.resize(frame, (0, 0), fx=0.7, fy=0.7)
        if cv2.waitKey(1) & 0xFF == ord('p'):
            cpt += 1
            if cpt == nbImages:
                cpt = 0
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    corners, ids, rejectedCandidates = detector.detectMarkers(gray)

    if ids is not None:
        # Recherche des indices des marqueurs BGCarte et BDCarte dans la liste ids
        bg_index = None
        bd_index = None
        Corner1 = None
        Corner2 = None
        Corner3 = None
        Corner4 = None
        for i in range(len(ids)):
            if ids[i] == 0:
                p1, p2, p3, p4 = corners[i][0]  # Extract corner points
                Corner1 = p1
            elif ids[i] == 1:
                p1, p2, p3, p4 = corners[i][0]  # Extract corner points
                Corner2 = p2
            elif ids[i] == 2:
                p1, p2, p3, p4 = corners[i][0]  # Extract corner points
                Corner3 = p3
            elif ids[i] == 3:
                p1, p2, p3, p4 = corners[i][0]  # Extract corner points
                Corner4 = p4

        M = calculate_perspective_transform_matrix(Corner1, Corner2, Corner4, Corner3, final_size)

        for i in range(len(ids)):
            TextOnScreen = "Inconnu"
            ColorText = (0, 0, 0)
            if ids[i] == 132:
                TextOnScreen = "NOUS"
                ColorText = (255, 0, 202)
            else:
                TextOnScreen = None
            frame = cv2.putText(img=frame, text=TextOnScreen, org=(int(corners[i][0][0][0]), int(corners[i][0][0][1])),
                                fontFace=cv2.FONT_HERSHEY_PLAIN, fontScale=2.0, color=ColorText, thickness=2)

        # Apply perspective transformation
        dst = cv2.warpPerspective(frame, M, final_size)

        cv2.imwrite("Images\Transformed_image.jpg", dst)

        # Open the image
        image = cv2.imread(
            "Images/Transformed_image.jpg")  # Replace "Images/Transformed_image.jpg" with the path to your image file

        # Define the dimensions of the centered rectangle
        crop_width = 1110
        crop_height = 710

        # Calculate the coordinates for cropping
        left = (image.shape[1] - crop_width) // 2
        top = (image.shape[0] - crop_height) // 2
        right = left + crop_width
        bottom = top + crop_height

        # Crop the image
        cropped_image = image[top:bottom, left:right]

        # Save the cropped image
        cv2.imwrite("Images/cropped_frame.jpg", cropped_image)  # Save the cropped image to a file


        # Display the result
        cv2.imshow('Perspective Transformation Result', dst)


        img_copy = dst.copy()
        # Define the centers of the circles
        circle_centers = [(103, 797), (140, 797), (175, 797), (215, 797), (250, 797)]
        circle_radius = 10
        # Get the mean HSV values for each circle
        mean_hsv_values = []

        for center in circle_centers:
            mean_hsv = get_mean_hsv(dst, center)
            mean_hsv_values.append(mean_hsv)
        for i in range(5):
            cv2.circle(img_copy, (circle_centers[i][0], circle_centers[i][1]), circle_radius, (mean_hsv_values[i][0],mean_hsv_values[i][1], mean_hsv_values[i][2]), -1)  # Draw filled circle

        # Print the mean HSV values
        for i in range(5):
            print(f"Circle {i + 1}: Mean HSV = {mean_hsv_values[i][0]} {mean_hsv_values[i][1]} {mean_hsv_values[i][2]}")
        img_copy = cv2.cvtColor(img_copy, cv2.COLOR_HSV2BGR)
        # cv2.imshow("Image with Circles", img_copy)

        hsv_img = cv2.cvtColor(dst, cv2.COLOR_BGR2HSV)
        for i in range(5):
            if i == 1:
                # Bleu
                bound_lower = np.array([mean_hsv_values[1][0] - 8, mean_hsv_values[1][1] -10 , mean_hsv_values[1][2] -10])
                bound_upper = np.array([mean_hsv_values[1][0] + 8, 255, 190])
                mask2 = cv2.inRange(hsv_img, bound_lower, bound_upper)
            elif i == 3:
                # Magenta
                bound_lower = np.array([mean_hsv_values[3][0] - 8, mean_hsv_values[3][1] - 100, mean_hsv_values[3][2] - 100])
                bound_upper = np.array([mean_hsv_values[3][0] + 8, 255, 255])
                mask4 = cv2.inRange(hsv_img, bound_lower, bound_upper)
            elif i == 4:
                # Rouge
                bound_lower = np.array([mean_hsv_values[4][0] - 8, mean_hsv_values[4][1] - 100, mean_hsv_values[4][2] - 100])
                bound_upper = np.array([mean_hsv_values[4][0] + 8, 255, 255])
                mask5 = cv2.inRange(hsv_img, bound_lower, bound_upper)

        kernel = np.ones((7, 7), np.uint8)


        mask2 = cv2.morphologyEx(mask2, cv2.MORPH_CLOSE, kernel)
        mask2 = cv2.morphologyEx(mask2, cv2.MORPH_OPEN, kernel)

        display_mask2 = cv2.bitwise_and(dst, dst, mask=mask2)

        mask4 = cv2.morphologyEx(mask4, cv2.MORPH_CLOSE, kernel)
        mask4 = cv2.morphologyEx(mask4, cv2.MORPH_OPEN, kernel)

        display_mask4 = cv2.bitwise_and(dst, dst, mask=mask4)

        mask5 = cv2.morphologyEx(mask5, cv2.MORPH_CLOSE, kernel)
        mask5 = cv2.morphologyEx(mask5, cv2.MORPH_OPEN, kernel)

        display_mask5 = cv2.bitwise_and(dst, dst, mask=mask5)

        cv2.imshow("Masque Bleu", display_mask2)
        cv2.imshow("Masque Magenta", display_mask4)
        cv2.imshow("Masque Rouge", display_mask5)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

if TEST != 1:
    cap.release()
cv2.destroyAllWindows()