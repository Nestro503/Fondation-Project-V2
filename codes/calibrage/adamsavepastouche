

    detector = cv2.aruco.ArucoDetector(arucoDict, arucoParams)

    corners, ids, rejected = detector.detectMarkers(img)



    cv2.imshow("Original Image", img)


    x_aruco_0, y_aruco_0, x_aruco_1, y_aruco_1, x_aruco_2, y_aruco_2, x_aruco_3, y_aruco_3 = trouver_arucos_coins(corners, ids)



    pts1 = np.float32([[x_aruco_0 - CONSTANTE_RECADRAGE, y_aruco_0 - CONSTANTE_RECADRAGE],[x_aruco_1 + CONSTANTE_RECADRAGE, y_aruco_1 - CONSTANTE_RECADRAGE],[x_aruco_3 - CONSTANTE_RECADRAGE, y_aruco_3 + CONSTANTE_RECADRAGE],[x_aruco_2 + CONSTANTE_RECADRAGE, y_aruco_2 + CONSTANTE_RECADRAGE]])
    pts2 = np.float32([[0, 0], [IMAGE_RECADRE_LONGUEUR, 0], [0, IMAGE_RECADRE_LARGEUR], [IMAGE_RECADRE_LONGUEUR, IMAGE_RECADRE_LARGEUR]])

    M = cv2.getPerspectiveTransform(pts1, pts2)


    img_recadre = cv2.warpPerspective(img, M, (IMAGE_RECADRE_LONGUEUR, IMAGE_RECADRE_LARGEUR))

    corners_recadre, ids_recadre, rejected = detector.detectMarkers(img_recadre)

    img_recadre = aruco_display(corners_recadre, ids_recadre, img_recadre)


    x_aruco_0, y_aruco_0, x_aruco_1, y_aruco_1, x_aruco_2, y_aruco_2, x_aruco_3, y_aruco_3 = trouver_arucos_coins(corners_recadre, ids_recadre)
    x_robot, y_robot = coordrobot(corners_recadre, ids_recadre)

    pixel_distance_x, mm_nbr_pixel_x, pixel_nbr_mm_x, pixel_distance_y, mm_nbr_pixel_y, pixel_nbr_mm_y = calcul_pixel_mm(x_aruco_0, y_aruco_0, x_aruco_1, y_aruco_1, x_aruco_2, y_aruco_2, x_aruco_3, y_aruco_3)

    # Check if coordinates are not None and draw the circle
    if x_robot is not None and y_robot is not None:
        cv2.circle(img_recadre, (int(x_robot), int(y_robot)), int(RADIUS_ROBOT*(mm_nbr_pixel_x+mm_nbr_pixel_y)/2), (234,	158,	236), 3)
    else:
        print("ArUco marker 137 not detected.")


    img_recadre = cercle_calib(x_aruco_0, y_aruco_0, x_aruco_1, y_aruco_1, x_aruco_2, y_aruco_2, x_aruco_3, y_aruco_3, mm_nbr_pixel_x, mm_nbr_pixel_y, img_recadre)








    # Coordonnées des pixels à vérifier
    pixel_rouge = (int(x_aruco_3 + TAILLE_ARUCO_COIN * mm_nbr_pixel_x + 6 * LONGUEUR_CALIBRATION * mm_nbr_pixel_x), int(y_aruco_3 ))
    pixel_gris =  (int(x_aruco_1 - TAILLE_ARUCO_COIN * mm_nbr_pixel_x - 9 * LONGUEUR_CALIBRATION * mm_nbr_pixel_x), int(y_aruco_1 ))

    # Obtenez la valeur BGR du pixel
    bgr_pixel_rouge = img_recadre[pixel_rouge[1], pixel_rouge[0]]
    bgr_pixel_gris = img_recadre[pixel_gris[1], pixel_gris[0]]

    # Dessinez un cercle avec la couleur du pixel
    cv2.circle(img_recadre, (int(IMAGE_RECADRE_LONGUEUR/2), int(IMAGE_RECADRE_LARGEUR/2)),
               10,
               (int(bgr_pixel_rouge[0]), int(bgr_pixel_rouge[1]), int(bgr_pixel_rouge[2])), -1)
    cv2.circle(img_recadre, (int(IMAGE_RECADRE_LONGUEUR/2 + 20), int(IMAGE_RECADRE_LARGEUR/2 + 20)),
               10,
               (int(bgr_pixel_gris[0]), int(bgr_pixel_gris[1]), int(bgr_pixel_gris[2])), -1)

    cv2.imshow("Image recadre", img_recadre)








    # Définir une tolérance pour la plage de couleur rouge autour du pixel de référence
    tolerance = 25  # Tolérance pour le rgb


    # Créer les bornes inférieure et supérieure pour le masque
    gris_lower = np.array(bgr_pixel_gris) - tolerance
    gris_upper = np.array(bgr_pixel_gris) + tolerance

    # Créer un masque qui détecte tous les pixels dans la plage de rouge définie
    mask_gris = cv2.inRange(img_recadre, gris_lower, gris_upper)

    # Remplacer la couleur rouge par du noir dans l'image originale
    img_recadre[mask_gris > 0] = [120, 120, 0]

    # Afficher l'image modifiée
    cv2.imshow("Image avec couleur de référence remplacée par du noir", img_recadre)




    '''
    # Convertir l'image BGR en HSV
    img_recadre_hsv = cv2.cvtColor(img_recadre, cv2.COLOR_BGR2HSV)

    # Obtenez la valeur HSV du pixel
    hsv_pixel_rouge = img_recadre_hsv[pixel_rouge[1], pixel_rouge[0]]

    # Définir des tolérances
    tolerance_hue = 10  # Tolérance pour la teinte
    tolerance_sat_val = 40  # Tolérance pour la saturation et la valeur

    teinte_rouge = hsv_pixel_rouge[0]
    saturation_rouge = hsv_pixel_rouge[1]
    valeur_rouge = hsv_pixel_rouge[2]


    # Bornes basées sur la teinte, la saturation, et la valeur du pixel rouge
    rouge_lower_hsv = np.array([max(teinte_rouge - tolerance_hue, 0), max(saturation_rouge - tolerance_sat_val, 100), max(valeur_rouge - tolerance_sat_val, 100)])
    rouge_upper_hsv = np.array([min(teinte_rouge + tolerance_hue, 180), min(saturation_rouge + tolerance_sat_val, 255), min(valeur_rouge + tolerance_sat_val, 255)])


    # Créer un masque HSV qui détecte tous les pixels dans la plage définie
    mask_rouge_hsv = cv2.inRange(img_recadre_hsv, rouge_lower_hsv, rouge_upper_hsv)

    # Remplacer la couleur détectée par une couleur spécifique (par exemple, noir avec une teinte jaune)
    img_recadre[mask_rouge_hsv > 0] = [120, 120, 0]  # BGR

    # Afficher l'image modifiée
    cv2.imshow("Image HSV avec couleur de référence remplacée par du noir ", img_recadre)
    '''










    key = cv2.waitKey(1) & 0xFF
    if key == ord("q"):
        break

cv2.destroyAllWindows()
cap.release()
